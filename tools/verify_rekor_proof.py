#!/usr/bin/env python3
"""Validate Rekor proof artifacts generated by tools/rekor_monitor.sh."""

from __future__ import annotations

import argparse
import base64
import json
from pathlib import Path
import os
import subprocess
from typing import Any, Iterable


def _load_json(path: Path) -> Any:
    try:
        raw = path.read_text(encoding="utf-8")
    except OSError as exc:  # pragma: no cover - surfaced via CLI
        raise SystemExit(f"[verify-rekor-proof] failed to read {path}: {exc}") from exc
    try:
        return json.loads(raw)
    except json.JSONDecodeError as exc:
        raise SystemExit(f"[verify-rekor-proof] {path} is not valid JSON: {exc}") from exc


def _normalize_proof(document: Any) -> dict[str, Any]:
    if isinstance(document, list):
        if not document:
            raise SystemExit("[verify-rekor-proof] proof JSON is an empty list")
        document = document[0]
    if not isinstance(document, dict):
        raise SystemExit("[verify-rekor-proof] proof output must be a JSON object")
    return document


def _extract_section(document: dict[str, Any], paths: tuple[tuple[str, ...], ...]) -> dict[str, Any] | None:
    for path in paths:
        current: Any = document
        for key in path:
            if not isinstance(current, dict):
                break
            current = current.get(key)
        else:
            if isinstance(current, dict):
                return current
    return None


def _normalize_digest(value: str | None) -> str:
    if not value:
        return ""
    value = value.strip().lower()
    if value.startswith("sha256:"):
        value = value[len("sha256:") :]
    return value


def _iter_subject_digests(entry: dict[str, Any]) -> Iterable[str]:
    def from_subject_list(subjects: Iterable[Any]) -> Iterable[str]:
        for item in subjects:
            if not isinstance(item, dict):
                continue
            digest = item.get("digest")
            if isinstance(digest, dict):
                value = digest.get("sha256")
                if isinstance(value, str):
                    yield value

    spec = entry.get("spec")
    if isinstance(spec, dict):
        # Direct hash references
        data_hash = spec.get("data", {}).get("hash", {})
        if isinstance(data_hash, dict):
            value = data_hash.get("value") or data_hash.get("sha256")
            if isinstance(value, str):
                yield value
        artifact_hash = spec.get("artifactHash", {})
        if isinstance(artifact_hash, dict):
            value = artifact_hash.get("value") or artifact_hash.get("sha256")
            if isinstance(value, str):
                yield value
        subjects = spec.get("subject")
        if isinstance(subjects, list):
            yield from from_subject_list(subjects)
        content = spec.get("content", {})
        if isinstance(content, dict):
            for key in ("payload", "envelope"):
                payload = content.get(key)
                if not isinstance(payload, str):
                    continue
                try:
                    decoded = base64.b64decode(payload + "==")
                except (ValueError, TypeError):
                    continue
                try:
                    data = json.loads(decoded)
                except json.JSONDecodeError:
                    continue
                candidates = data if isinstance(data, list) else [data]
                for candidate in candidates:
                    if isinstance(candidate, dict):
                        subjects = candidate.get("subject")
                        if isinstance(subjects, list):
                            yield from from_subject_list(subjects)


def _extract_entry_digests(log_entry: dict[str, Any]) -> set[str]:
    body = log_entry.get("body")
    if not isinstance(body, str):
        return set()
    try:
        decoded = base64.b64decode(body + "==")
    except (ValueError, TypeError):
        return set()
    try:
        payload = json.loads(decoded)
    except json.JSONDecodeError:
        return set()
    payloads = payload if isinstance(payload, list) else [payload]
    results: set[str] = set()
    for entry in payloads:
        if isinstance(entry, dict):
            for digest in _iter_subject_digests(entry):
                norm = _normalize_digest(digest)
                if norm:
                    results.add(norm)
    return results


def _ensure_inclusion(verification: dict[str, Any]) -> None:
    inclusion = verification.get("inclusionProof") or verification.get("InclusionProof")
    if not isinstance(inclusion, dict):
        raise SystemExit("[verify-rekor-proof] inclusion proof missing from verification block")
    required_fields = ("logIndex", "treeSize", "rootHash", "hashes")
    for field in required_fields:
        if field not in inclusion:
            raise SystemExit(f"[verify-rekor-proof] inclusion proof missing '{field}' field")
    if not inclusion["hashes"]:
        raise SystemExit("[verify-rekor-proof] inclusion proof contains no hashes")


def _ensure_signed_timestamp(proof: dict[str, Any], verification: dict[str, Any]) -> None:
    candidates = [
        proof.get("signedEntryTimestamp"),
        proof.get("SignedEntryTimestamp"),
        verification.get("signedEntryTimestamp"),
        verification.get("SignedEntryTimestamp"),
    ]
    for item in candidates:
        if isinstance(item, str) and item.strip():
            return
    raise SystemExit("[verify-rekor-proof] signedEntryTimestamp missing from proof output")


def verify_proof(proof_path: Path, expected_digest: str | None) -> dict[str, Any]:
    proof = _normalize_proof(_load_json(proof_path))

    verification = _extract_section(
        proof,
        (
            ("verification",),
            ("Verification",),
            ("entry", "verification"),
            ("entry", "Verification"),
            ("Entry", "verification"),
            ("Entry", "Verification"),
        ),
    )
    if not isinstance(verification, dict):
        # Fallback: try to fetch the entry directly via rekor-cli when verification is missing
        verification = {}


    log_entry = _extract_section(
        proof,
        (
            ("logEntry",),
            ("LogEntry",),
            ("entry",),
            ("Entry",),
        ),
    )
    if not isinstance(log_entry, dict):
        raise SystemExit("[verify-rekor-proof] logEntry missing from proof output")

    uuid = log_entry.get("uuid") or log_entry.get("UUID")
    if uuid is None:
        raise SystemExit("[verify-rekor-proof] logEntry missing uuid field")
    if "logIndex" not in log_entry and "LogIndex" not in log_entry:
        raise SystemExit("[verify-rekor-proof] logEntry missing logIndex field")

    if not verification:
        verification = _fetch_verification(uuid, log_entry)
    _ensure_inclusion(verification)
    _ensure_signed_timestamp(proof, verification)

    if expected_digest:
        normalized_expected = _normalize_digest(expected_digest)
        digests = _extract_entry_digests(log_entry)
        if normalized_expected not in digests:
            raise SystemExit(
                "[verify-rekor-proof] expected digest not present in logEntry body; "
                f"wanted {normalized_expected}, got {sorted(digests)}"
            )
    proof.setdefault("verification", verification)
    return proof


def _fetch_verification(uuid: str, existing_log_entry: dict[str, Any]) -> dict[str, Any]:
    rekor_log = os.environ.get("REKOR_LOG", "https://rekor.sigstore.dev")
    cmd = [
        "rekor-cli",
        "get",
        "--uuid",
        uuid,
        "--log-url",
        rekor_log,
        "--format",
        "json",
    ]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)  # noqa: S603
    except FileNotFoundError as exc:  # pragma: no cover - runtime dependency
        raise SystemExit("[verify-rekor-proof] rekor-cli not found; install to verify proofs") from exc
    except subprocess.CalledProcessError as exc:
        raise SystemExit(
            f"[verify-rekor-proof] failed to fetch Rekor entry {uuid}: {exc.stderr or exc.stdout}"
        ) from exc

    try:
        entry = json.loads(result.stdout or "{}")
    except json.JSONDecodeError as exc:  # pragma: no cover
        raise SystemExit(f"[verify-rekor-proof] rekor-cli get returned invalid JSON: {exc}") from exc

    verification = entry.get("verification") or entry.get("Verification")
    if not isinstance(verification, dict):
        raise SystemExit("[verify-rekor-proof] verification block missing from Rekor entry fetch")

    log_entry = (
        entry.get("logEntry")
        or entry.get("LogEntry")
        or entry.get("entry")
        or entry.get("Entry")
    )
    if isinstance(log_entry, dict):
        existing_log_entry.update(log_entry)

    return verification


def load_index(index_path: Path) -> dict[str, Any]:
    index = _load_json(index_path)
    if not isinstance(index, dict):
        raise SystemExit("[verify-rekor-proof] index file must be a JSON object")
    for field in ("digest", "proof_path", "uuid"):
        if field not in index or not isinstance(index[field], str) or not index[field]:
            raise SystemExit(f"[verify-rekor-proof] index missing '{field}' value")
    return index


def find_latest_index(directory: Path) -> Path:
    candidates = sorted(directory.glob("rekor-proof-index-*.json"))
    if not candidates:
        raise SystemExit(f"[verify-rekor-proof] no rekor-proof-index files found in {directory}")
    return candidates[-1]


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Validate Rekor proof artifacts")
    parser.add_argument(
        "--index",
        help="Path to rekor-proof-index JSON (defaults to latest in --evidence-dir)",
    )
    parser.add_argument(
        "--evidence-dir",
        default="artifacts/evidence",
        help="Directory containing rekor-proof-index files (default: artifacts/evidence)",
    )
    parser.add_argument(
        "--proof",
        help="Explicit path to rekor proof JSON. Overrides index lookup.",
    )
    parser.add_argument(
        "--digest",
        help="Expected image digest (sha256:...). If omitted, uses value from index file.",
    )
    return parser


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    index_path: Path | None = Path(args.index) if args.index else None
    if not index_path:
        index_path = find_latest_index(Path(args.evidence_dir))
    index = load_index(index_path)

    proof_path = Path(args.proof) if args.proof else Path(index["proof_path"])
    if not proof_path.is_file():
        alt_path = index_path.parent / proof_path.name
        if alt_path.is_file():
            proof_path = alt_path
        else:
            raise SystemExit(f"[verify-rekor-proof] proof file {proof_path} not found")

    digest = args.digest or index["digest"]
    verify_proof(proof_path, digest)
    print(
        f"[verify-rekor-proof] verified inclusion proof {proof_path} (digest={digest}, uuid={index.get('uuid','')})"
    )
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
