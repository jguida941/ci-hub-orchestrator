# ============================================================================
# CI/CD Hub - Main Orchestrator
# ============================================================================
# This workflow orchestrates CI/CD for all configured repositories.
# It reads config, triggers builds, and aggregates reports.
#
# Triggers:
#   - Manual dispatch (workflow_dispatch)
#   - Scheduled (e.g., nightly)
#   - When config changes
# ============================================================================

name: Hub Orchestrator

on:
  workflow_dispatch:
    inputs:
      repos:
        description: 'Comma-separated repo names (empty = all)'
        required: false
        type: string

  schedule:
    # Run nightly at 2 AM UTC
    - cron: '0 2 * * *'

  push:
    branches: [main, master]
    paths:
      - 'config/**'
      - '.github/workflows/hub-orchestrator.yml'

# Minimal default permissions - jobs override as needed
permissions:
  contents: read

# Prevent concurrent runs for the same ref
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # Load Configuration
  # ============================================================================
  load-config:
    name: Load Repository Config
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      matrix: ${{ steps.config.outputs.matrix }}
      repo_count: ${{ steps.config.outputs.count }}

    steps:
      - name: Checkout Hub
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1
          persist-credentials: false
          ref: ${{ github.sha }}

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5
        with:
          python-version: '3.12'

      - name: Install Dependencies
        run: pip install pyyaml jsonschema

      - name: Generate Build Matrix
        id: config
        run: |
          python << 'EOF'
          import json
          import os
          import sys
          from pathlib import Path
          from scripts.load_config import load_config, generate_workflow_inputs

          hub_root = Path(".")
          repos_dir = hub_root / "config" / "repos"
          matrix_entries = []

          # Optional filter
          filter_repos = os.environ.get("INPUT_REPOS", "").strip()
          filter_list = [r.strip() for r in filter_repos.split(",")] if filter_repos else None

          for config_file in sorted(repos_dir.glob("*.yaml")):
              repo_name = config_file.stem
              try:
                  cfg = load_config(repo_name=repo_name, hub_root=hub_root)
              except SystemExit:
                  raise
              except Exception as exc:
                  print(f"Failed to load config {config_file}: {exc}", file=sys.stderr)
                  sys.exit(1)

              repo_info = cfg.get("repo", {})
              if not (repo_info.get("owner") and repo_info.get("name") and (repo_info.get("language") or cfg.get("language"))):
                  print(f"Skipping {config_file}: missing repo.owner/name/language")
                  continue
              if filter_list and repo_info.get("name", repo_name) not in filter_list:
                  continue

              inputs = generate_workflow_inputs(cfg)
              language = repo_info.get("language", cfg.get("language", "java"))
              # Default dispatch workflow: hub-ci.yml (generated by cihub init)
              default_workflow = "hub-ci.yml"
              entry = {
                  "config_file": str(config_file),
                  "config_basename": config_file.stem,  # Unique per config for artifact naming
                  "name": repo_info.get("name", repo_name),
                  "owner": repo_info.get("owner", "jguida941"),
                  "language": language,
                  "default_branch": repo_info.get("default_branch", "main"),
                  "subdir": repo_info.get("subdir", ""),
                  "dispatch_enabled": repo_info.get("dispatch_enabled", True),
                  "dispatch_workflow": repo_info.get("dispatch_workflow", default_workflow),
                  "run_group": repo_info.get("run_group", "full"),
              }
              entry.update(inputs)
              matrix_entries.append(entry)

          matrix = {"include": matrix_entries}

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"matrix={json.dumps(matrix)}\n")
              f.write(f"count={len(matrix_entries)}\n")

          print(f"Found {len(matrix_entries)} repositories:")
          for r in matrix_entries:
              print(f"  - {r['owner']}/{r['name']} ({r['language']}) run_group={r.get('run_group','full')}")
          EOF
        env:
          INPUT_REPOS: ${{ inputs.repos || '' }}

      - name: Summary
        env:
          REPO_COUNT: ${{ steps.config.outputs.count }}
        run: |
          {
            echo "## Hub Orchestrator"
            echo ""
            echo "**Repositories to build:** $REPO_COUNT"
          } >> "$GITHUB_STEP_SUMMARY"

  # ============================================================================
  # Trigger Builds for Each Repo
  # ============================================================================
  trigger-builds:
    name: Build ${{ matrix.config_basename }}
    runs-on: ubuntu-latest
    needs: load-config
    if: needs.load-config.outputs.repo_count > 0
    permissions:
      contents: read
      actions: write  # For workflow dispatch
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.load-config.outputs.matrix) }}

    steps:
      - name: Checkout Hub
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1
          persist-credentials: false
          ref: ${{ github.sha }}


      - name: Trigger Repository Workflow
        id: dispatch
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        env:
          # Pass matrix/step values via env vars to prevent expression injection
          MATRIX_OWNER: ${{ matrix.owner }}
          MATRIX_NAME: ${{ matrix.name }}
          MATRIX_LANGUAGE: ${{ matrix.language }}
          MATRIX_BRANCH: ${{ matrix.default_branch }}
          MATRIX_CONFIG_BASENAME: ${{ matrix.config_basename }}
          MATRIX_DISPATCH_ENABLED: ${{ matrix.dispatch_enabled }}
          MATRIX_DISPATCH_WORKFLOW: ${{ matrix.dispatch_workflow }}
          GH_RUN_ID: ${{ github.run_id }}
          GH_RUN_ATTEMPT: ${{ github.run_attempt }}
        with:
          github-token: ${{ secrets.HUB_DISPATCH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            // Read values from environment variables (prevents expression injection)
            const owner = process.env.MATRIX_OWNER;
            const repo = process.env.MATRIX_NAME;
            const branch = process.env.MATRIX_BRANCH;
            const dispatchEnabled = (process.env.MATRIX_DISPATCH_ENABLED || '').toLowerCase() !== 'false';
            const correlationId = `${process.env.GH_RUN_ID}-${process.env.GH_RUN_ATTEMPT || '1'}-${process.env.MATRIX_CONFIG_BASENAME}`;

            if (!dispatchEnabled) {
              core.info(`Dispatch disabled for ${owner}/${repo}; skipping dispatch.`);
              return;
            }

            const inputs = { hub_correlation_id: correlationId };
            const MAX_POLL_MS = 30 * 60 * 1000; // 30 minutes

            // Use configurable workflow name from matrix, with fallback to hub-ci.yml
            const workflowId = process.env.MATRIX_DISPATCH_WORKFLOW || 'hub-ci.yml';
            const startedAt = Date.now();

            core.info(`Dispatching ${workflowId} on ${owner}/${repo}@${branch}`);
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner,
                repo,
                workflow_id: workflowId,
                ref: branch,
                inputs,
              });
            } catch (err) {
              core.setFailed(`Dispatch failed for ${owner}/${repo}: ${err.message}`);
              throw err;
            }

            let runId = '';
            let pollDelay = 5000;
            const deadline = startedAt + MAX_POLL_MS;

            while (Date.now() < deadline) {
              await new Promise((resolve) => setTimeout(resolve, pollDelay));
              const runs = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: workflowId,
                event: 'workflow_dispatch',
                branch,
                per_page: 5,
              });

            const recent = runs.data.workflow_runs.find((run) => {
                const created = new Date(run.created_at).getTime();
                return (
                  created >= startedAt - 2000 && // tighter window to reduce collisions
                  run.head_branch === branch &&
                  run.status !== 'completed'
                );
              });

              if (recent) {
                runId = String(recent.id);
                core.info(`Captured run id ${runId} for ${repo}`);
                break;
              }

              pollDelay = Math.min(pollDelay * 2, 30000); // backoff up to 30s
            }

            if (!runId) {
              core.setFailed(`Dispatched ${workflowId} for ${repo}, but could not determine run id.`);
              return;
            }

            core.setOutput('run_id', runId);
            core.setOutput('branch', branch);
            core.setOutput('workflow_id', workflowId);
            core.setOutput('correlation_id', correlationId);

      - name: Record Build Trigger
        env:
          MATRIX_NAME: ${{ matrix.name }}
          MATRIX_OWNER: ${{ matrix.owner }}
          MATRIX_LANGUAGE: ${{ matrix.language }}
          MATRIX_BRANCH: ${{ matrix.default_branch }}
          STEP_WORKFLOW_ID: ${{ steps.dispatch.outputs.workflow_id }}
          STEP_RUN_ID: ${{ steps.dispatch.outputs.run_id }}
        run: |
          {
            echo "## $MATRIX_NAME"
            echo ""
            echo "- **Owner:** $MATRIX_OWNER"
            echo "- **Language:** $MATRIX_LANGUAGE"
            echo "- **Branch:** $MATRIX_BRANCH"
            echo "- **Workflow:** $STEP_WORKFLOW_ID"
            echo "- **Run ID:** ${STEP_RUN_ID:-pending}"
            echo "- **Status:** Triggered"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Save Dispatch Metadata
        if: always()
        env:
          MATRIX_CONFIG_BASENAME: ${{ matrix.config_basename }}
          MATRIX_OWNER: ${{ matrix.owner }}
          MATRIX_NAME: ${{ matrix.name }}
          MATRIX_SUBDIR: ${{ matrix.subdir }}
          MATRIX_LANGUAGE: ${{ matrix.language }}
          MATRIX_BRANCH: ${{ matrix.default_branch }}
          STEP_WORKFLOW_ID: ${{ steps.dispatch.outputs.workflow_id }}
          STEP_RUN_ID: ${{ steps.dispatch.outputs.run_id }}
          STEP_CORRELATION_ID: ${{ steps.dispatch.outputs.correlation_id }}
          JOB_STATUS: ${{ job.status }}
        run: |
          mkdir -p dispatch-results
          cat > "dispatch-results/${MATRIX_CONFIG_BASENAME}.json" << EOF
          {
            "config": "${MATRIX_CONFIG_BASENAME}",
            "repo": "${MATRIX_OWNER}/${MATRIX_NAME}",
            "subdir": "${MATRIX_SUBDIR}",
            "language": "${MATRIX_LANGUAGE}",
            "branch": "${MATRIX_BRANCH}",
            "workflow": "${STEP_WORKFLOW_ID}",
            "run_id": "${STEP_RUN_ID}",
            "correlation_id": "${STEP_CORRELATION_ID}",
            "dispatch_time": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "status": "${JOB_STATUS}"
          }
          EOF

      - name: Upload Dispatch Metadata
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: dispatch-${{ matrix.config_basename }}-${{ github.run_id }}
          path: dispatch-results/${{ matrix.config_basename }}.json
          retention-days: 7

  # ============================================================================
  # Aggregate Reports
  # ============================================================================
  aggregate-reports:
    name: Aggregate Reports
    runs-on: ubuntu-latest
    needs: [load-config, trigger-builds]
    if: always()
    permissions:
      contents: read
      actions: read  # For reading run artifacts

    steps:
      - name: Checkout Hub
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1
          persist-credentials: false
          ref: ${{ github.sha }}

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5
        with:
          python-version: '3.12'

      - name: Install Dependencies
        run: pip install pyyaml

      - name: Download Dispatch Metadata
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4
        with:
          path: dispatch-artifacts
        continue-on-error: true

      - name: Generate Hub Summary and Report
        env:
          TOTAL_REPOS: ${{ needs.load-config.outputs.repo_count }}
          HUB_RUN_ID: ${{ github.run_id }}
          HUB_EVENT: ${{ github.event_name }}
          # Use HUB_DISPATCH_TOKEN for cross-repo artifact access
          HUB_DISPATCH_TOKEN: ${{ secrets.HUB_DISPATCH_TOKEN }}
        run: |
          if [ -z "${HUB_DISPATCH_TOKEN}" ]; then
            echo "::error::HUB_DISPATCH_TOKEN is required for cross-repo artifact access"
            exit 1
          fi
          python -m cihub report aggregate \
            --dispatch-dir dispatch-artifacts \
            --output hub-report.json \
            --summary-file "$GITHUB_STEP_SUMMARY" \
            --defaults-file config/defaults.yaml

      - name: Upload Hub Report
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: hub-report-${{ github.run_id }}
          path: hub-report.json
          retention-days: 30
